#pragma once

// clang-format off
// generated by thirdparty/sqlpp23/scripts/sqlpp23-ddl2cpp --path-to-ddl schema/qwparity_schema.sql --namespace moller::db::schema --path-to-header include/mollerdb/schema/qwparity_schema.h --path-to-custom-types schema/custom_types.csv

#include <optional>

#include <sqlpp23/core/basic/table.h>
#include <sqlpp23/core/basic/table_columns.h>
#include <sqlpp23/core/name/create_name_tag.h>
#include <sqlpp23/core/type_traits.h>

namespace moller::db::schema {
  struct GoodFor_ {
    struct GoodForId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(good_for_id, goodForId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Type {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(type, type);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(good_for, goodFor);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               GoodForId,
               Type>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using GoodFor = ::sqlpp::table_t<GoodFor_>;

  struct RunQuality_ {
    struct RunQualityId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(run_quality_id, runQualityId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Type {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(type, type);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(run_quality, runQuality);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               RunQualityId,
               Type>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using RunQuality = ::sqlpp::table_t<RunQuality_>;

  struct Seeds_ {
    struct SeedId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(seed_id, seedId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct FirstRunId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(first_run_id, firstRunId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct LastRunId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(last_run_id, lastRunId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Seed {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(seed, seed);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct Comment {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(comment, comment);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(seeds, seeds);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SeedId,
               FirstRunId,
               LastRunId,
               Seed,
               Comment>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<Seeds_>, FirstRunId>,
               sqlpp::column_t<sqlpp::table_t<Seeds_>, LastRunId>>;
  };
  using Seeds = ::sqlpp::table_t<Seeds_>;

  struct ParameterFiles_ {
    struct ParameterFileId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(parameter_file_id, parameterFileId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct AnalysisId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(analysis_id, analysisId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Filename {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(filename, filename);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(parameter_files, parameterFiles);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               ParameterFileId,
               AnalysisId,
               Filename>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<ParameterFiles_>, AnalysisId>,
               sqlpp::column_t<sqlpp::table_t<ParameterFiles_>, Filename>>;
  };
  using ParameterFiles = ::sqlpp::table_t<ParameterFiles_>;

  struct ErrorCode_ {
    struct ErrorCodeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(error_code_id, errorCodeId);
      using data_type = ::sqlpp::integral;
      using has_default = std::true_type;
    };
    struct Quantity {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(quantity, quantity);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(error_code, errorCode);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               ErrorCodeId,
               Quantity>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<ErrorCode_>, Quantity>>;
  };
  using ErrorCode = ::sqlpp::table_t<ErrorCode_>;

  struct SlopeType_ {
    struct SlopeTypeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slope_type_id, slopeTypeId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Slope {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slope, slope);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Units {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(units, units);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Title {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(title, title);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slope_type, slopeType);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SlopeTypeId,
               Slope,
               Units,
               Title>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<SlopeType_>, Slope>,
               sqlpp::column_t<sqlpp::table_t<SlopeType_>, Units>,
               sqlpp::column_t<sqlpp::table_t<SlopeType_>, Title>>;
  };
  using SlopeType = ::sqlpp::table_t<SlopeType_>;

  struct Monitor_ {
    struct MonitorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(monitor_id, monitorId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Quantity {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(quantity, quantity);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Title {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(title, title);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(monitor, monitor);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               MonitorId,
               Quantity,
               Title>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<Monitor_>, Quantity>,
               sqlpp::column_t<sqlpp::table_t<Monitor_>, Title>>;
  };
  using Monitor = ::sqlpp::table_t<Monitor_>;

  struct MainDetector_ {
    struct MainDetectorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(main_detector_id, mainDetectorId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Quantity {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(quantity, quantity);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Title {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(title, title);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(main_detector, mainDetector);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               MainDetectorId,
               Quantity,
               Title>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<MainDetector_>, Quantity>,
               sqlpp::column_t<sqlpp::table_t<MainDetector_>, Title>>;
  };
  using MainDetector = ::sqlpp::table_t<MainDetector_>;

  struct LumiDetector_ {
    struct LumiDetectorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(lumi_detector_id, lumiDetectorId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Quantity {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(quantity, quantity);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Title {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(title, title);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(lumi_detector, lumiDetector);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               LumiDetectorId,
               Quantity,
               Title>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<LumiDetector_>, Quantity>,
               sqlpp::column_t<sqlpp::table_t<LumiDetector_>, Title>>;
  };
  using LumiDetector = ::sqlpp::table_t<LumiDetector_>;

  struct SlowControlsSettings_ {
    struct SlowControlsSettingsId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_settings_id, slowControlsSettingsId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct RunletId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(runlet_id, runletId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct SlowHelicityPlate {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_helicity_plate, slowHelicityPlate);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct PassiveHelicityPlate {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(passive_helicity_plate, passiveHelicityPlate);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct WienReversal {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(wien_reversal, wienReversal);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct PrecessionReversal {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(precession_reversal, precessionReversal);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct HelicityLength {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(helicity_length, helicityLength);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct ChargeFeedback {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(charge_feedback, chargeFeedback);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct PositionFeedback {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(position_feedback, positionFeedback);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct QtorCurrent {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(qtor_current, qtorCurrent);
      using data_type = std::optional<::sqlpp::floating_point>;
      using has_default = std::true_type;
    };
    struct TargetPosition {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(target_position, targetPosition);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_settings, slowControlsSettings);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SlowControlsSettingsId,
               RunletId,
               SlowHelicityPlate,
               PassiveHelicityPlate,
               WienReversal,
               PrecessionReversal,
               HelicityLength,
               ChargeFeedback,
               PositionFeedback,
               QtorCurrent,
               TargetPosition>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<SlowControlsSettings_>, RunletId>>;
  };
  using SlowControlsSettings = ::sqlpp::table_t<SlowControlsSettings_>;

  struct ScDetector_ {
    struct ScDetectorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(sc_detector_id, scDetectorId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Name {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(name, name);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Units {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(units, units);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct Comment {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(comment, comment);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(sc_detector, scDetector);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               ScDetectorId,
               Name,
               Units,
               Comment>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<ScDetector_>, Name>,
               sqlpp::column_t<sqlpp::table_t<ScDetector_>, Units>,
               sqlpp::column_t<sqlpp::table_t<ScDetector_>, Comment>>;
  };
  using ScDetector = ::sqlpp::table_t<ScDetector_>;

  struct SlowControlsData_ {
    struct SlowControlsDataId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_data_id, slowControlsDataId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct RunletId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(runlet_id, runletId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct ScDetectorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(sc_detector_id, scDetectorId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct N {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(n, n);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Value {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(value, value);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct Error {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(error, error);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct MinValue {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(min_value, minValue);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct MaxValue {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(max_value, maxValue);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_data, slowControlsData);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SlowControlsDataId,
               RunletId,
               ScDetectorId,
               N,
               Value,
               Error,
               MinValue,
               MaxValue>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, RunletId>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, ScDetectorId>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, N>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, Value>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, Error>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, MinValue>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsData_>, MaxValue>>;
  };
  using SlowControlsData = ::sqlpp::table_t<SlowControlsData_>;

  struct SlowControlsStrings_ {
    struct SlowControlsStringsId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_strings_id, slowControlsStringsId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct RunletId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(runlet_id, runletId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct ScDetectorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(sc_detector_id, scDetectorId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Value {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(value, value);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(slow_controls_strings, slowControlsStrings);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SlowControlsStringsId,
               RunletId,
               ScDetectorId,
               Value>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<SlowControlsStrings_>, RunletId>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsStrings_>, ScDetectorId>,
               sqlpp::column_t<sqlpp::table_t<SlowControlsStrings_>, Value>>;
  };
  using SlowControlsStrings = ::sqlpp::table_t<SlowControlsStrings_>;

  struct BfTest_ {
    struct BfTestId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bf_test_id, bfTestId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct AnalysisId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(analysis_id, analysisId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct TestNumber {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(test_number, testNumber);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct TestValue {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(test_value, testValue);
      using data_type = std::optional<::sqlpp::floating_point>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bf_test, bfTest);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               BfTestId,
               AnalysisId,
               TestNumber,
               TestValue>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<BfTest_>, AnalysisId>>;
  };
  using BfTest = ::sqlpp::table_t<BfTest_>;

  struct ModulationType_ {
    struct ModulationTypeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(modulation_type_id, modulationTypeId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Type {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(type, type);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(modulation_type, modulationType);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               ModulationTypeId,
               Type>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using ModulationType = ::sqlpp::table_t<ModulationType_>;

  struct BeamOptics_ {
    struct BeamOpticsId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(beam_optics_id, beamOpticsId);
      using data_type = const std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct AnalysisId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(analysis_id, analysisId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct MonitorId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(monitor_id, monitorId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct ModulationTypeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(modulation_type_id, modulationTypeId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct N {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(n, n);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Amplitude {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(amplitude, amplitude);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct Phase {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(phase, phase);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct Offset {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(offset, offset);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct AError {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(a_error, aError);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct PError {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(p_error, pError);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct OError {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(o_error, oError);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    struct GofPara {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(gof_para, gofPara);
      using data_type = ::sqlpp::floating_point;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(beam_optics, beamOptics);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               BeamOpticsId,
               AnalysisId,
               MonitorId,
               ModulationTypeId,
               N,
               Amplitude,
               Phase,
               Offset,
               AError,
               PError,
               OError,
               GofPara>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, AnalysisId>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, MonitorId>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, ModulationTypeId>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, N>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, Amplitude>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, Phase>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, Offset>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, AError>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, PError>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, OError>,
               sqlpp::column_t<sqlpp::table_t<BeamOptics_>, GofPara>>;
  };
  using BeamOptics = ::sqlpp::table_t<BeamOptics_>;

} // namespace moller::db::schema
